#!/usr/bin/env python3
import os
import subprocess
import tkinter as tk
from langchain.chains import RetrievalQA
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler
from langchain_community.vectorstores import Chroma
from langchain_community.llms import Ollama
import chromadb
import argparse
import time
import winreg

model = os.environ.get("MODEL", "mistral")
embeddings_model_name = os.environ.get("EMBEDDINGS_MODEL_NAME", "all-MiniLM-L6-v2")
persist_directory = os.environ.get("PERSIST_DIRECTORY", "db")
target_source_chunks = int(os.environ.get('TARGET_SOURCE_CHUNKS', 4))

def main():
    # Create GUI window
    window = tk.Tk()
    window.title("Antivirus")

    # Create label
    label = tk.Label(window, text="Click the button to have a check of the vulnerabilities in your own programs")
    label.pack()

    # Create button
    button = tk.Button(window, text="Fast Check", command=get_answer)
    button.pack()

    # Run GUI
    window.mainloop()


def get_answer():
    try:
        # Initialize embeddings
        embeddings = HuggingFaceEmbeddings(model_name=embeddings_model_name)

        # Initialize Chroma
        db = Chroma(persist_directory=persist_directory, embedding_function=embeddings)

        # Initialize retriever
        retriever = db.as_retriever(search_kwargs={"k": target_source_chunks})

        # Initialize LLM
        llm = Ollama(model=model, callbacks=[])

        # Initialize QA
        qa = RetrievalQA.from_chain_type(llm=llm, chain_type="stuff", retriever=retriever, return_source_documents=False)

        # Automatically pose the question along with the list of applications
        applications = get_applications_list()
        if applications:
            # Construct the question including the list of applications
            question = f"[Context: think that you are an antivirus] Are there any CVEs (notes) in these programs? {' + '.join([f'{app} (Version: {version})' for app, version in applications])}, check based on the version of the apps provided. And answer 'Yes' if there are or 'No' if there are not"
            print(question)
            
            # Get the answer
            res = qa.invoke(question)
            answer = res['result']
            print(answer)
            
            # Create new window to display the answer
            answer_window = tk.Toplevel()
            answer_window.title("Answer")

            answer_label = tk.Label(answer_window, text=f"Answer: {answer}", padx=10, pady=10, wraplength=300)
            answer_label.pack()

            answer_window.update_idletasks()
            width = answer_label.winfo_reqwidth() + 20  
            height = answer_label.winfo_reqheight() + 20  
            answer_window.geometry(f"{width}x{height}")

        else:
            print("Unable to get the list of programs in the Applications folder. Exiting.")

    except Exception as e:
        print("An error occurred:", e)


def get_applications_list():
    if os.name == 'nt':  
        return get_installed_programs()
    else:
        try:
            applications_folder = '/Applications'  # Path to the Applications folder on macOS
            if os.path.exists(applications_folder):
                applications = []
                for app_name in os.listdir(applications_folder):
                    app_path = os.path.join(applications_folder, app_name)
                    # Obtain the version of the program using the 'mdls' command
                    result = subprocess.run(['mdls', '-name', 'kMDItemVersion', '-raw', app_path], capture_output=True, text=True)
                    if result.returncode == 0:
                        app_version = result.stdout.strip()
                        applications.append((app_name, app_version))
                    else:
                        # If it's not possible to get the version, add only the program name
                        applications.append((app_name, "Unknown Version"))
                return applications
            else:
                print("The Applications folder does not exist.")
                return None
        except Exception as e:
            print("An error occurred:", e)
            return None


def get_installed_programs():

    installed_programs = {}
    uninstall_key = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
    try:
        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, uninstall_key) as key:
            for i in range(0, winreg.QueryInfoKey(key)[0]):
                subkey_name = winreg.EnumKey(key, i)
                with winreg.OpenKey(key, subkey_name) as subkey:
                    try:
                        program_name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                        program_version = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                        installed_programs[program_name] = program_version
                    except FileNotFoundError:
                        pass
    except Exception as e:
        print("Errore durante la lettura del registro di sistema:", e)
    return installed_programs


if __name__ == "__main__":
    main()
